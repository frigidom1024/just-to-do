# 代码评审统一标准

## 评审原则

代码评审的目的是：
1. **提高代码质量**：发现并修复潜在问题
2. **知识共享**：通过评审分享最佳实践
3. **保持一致性**：确保代码风格和架构的一致性
4. **促进成长**：帮助团队成员提升编程技能

## 优先级分类

### 🔴 严重问题（P0 - 必须修复）
阻塞问题，必须修复才能合并代码。

**包括但不限于：**
- 安全漏洞（SQL 注入、XSS、敏感信息泄露等）
- 违反 SOLID 原则导致架构问题
- 严重的性能问题（N+1 查询、内存泄漏等）
- 并发安全问题（数据竞争、死锁等）
- 资源泄漏（未关闭连接、文件等）
- 业务逻辑错误
- 破坏依赖方向的架构问题

### 🟡 中等问题（P1 - 建议修复）
影响代码质量但不阻塞合并的问题。

**包括但不限于：**
- 命名不规范或不易理解
- 错误处理不完善
- 缺少必要的注释
- 日志使用不规范
- 可以优化的性能问题
- 过度复杂的逻辑
- 代码重复

### 🟢 轻微问题（P2 - 可选修复）
代码风格和优化建议。

**包括但不限于：**
- 代码风格不一致
- 可读性可以改进
- 小的优化建议
- 可以简化的代码

### ✅ 优秀实践
值得学习和推广的实现。

**包括：**
- 清晰的架构设计
- 优雅的代码实现
- 完善的错误处理
- 良好的性能优化
- 出色的测试覆盖

## DDD 分层评审标准

### Domain 层（领域层）
**职责**：实现核心业务逻辑和领域模型

**评审重点：**
- [ ] 不依赖任何其他层（Infrastructure/Application/Interface）
- [ ] 使用充血模型，业务逻辑封装在实体内
- [ ] 聚合根维护一致性边界
- [ ] 值对象不可变
- [ ] 领域服务实现无状态的业务逻辑
- [ ] 仓储接口定义在此层
- [ ] 不依赖具体技术实现（数据库、HTTP 等）

**常见问题：**
- ❌ 领域实体调用 Repository 或数据库
- ❌ 领域层依赖 HTTP 或其他技术细节
- ❌ 使用贫血模型，业务逻辑散落在 Service 层
- ❌ 实体直接暴露内部状态修改

### Application 层（应用层）
**职责**：编排用例，协调领域对象和基础设施

**评审重点：**
- [ ] 只依赖 Domain 层
- [ ] 定义应用服务（Application Service）
- [ ] 实现用例（Use Case）
- [ ] 处理事务管理
- [ ] 发布领域事件
- [ ] 使用 DTO 进行数据传输
- [ ] 不包含业务逻辑（业务逻辑在 Domain 层）

**常见问题：**
- ❌ 应用服务包含业务规则
- ❌ 直接访问数据库
- ❌ 跨层调用 Infrastructure 层
- ❌ 缺少事务管理

### Infrastructure 层（基础设施层）
**职责**：提供技术实现（数据库、缓存、消息队列等）

**评审重点：**
- [ ] 实现 Domain 层定义的接口
- [ ] 不包含业务逻辑
- [ ] 关注技术实现细节
- [ ] 处理持久化、外部服务调用
- [ ] 可以被 Application 层使用

**常见问题：**
- ❌ 包含业务逻辑
- ❌ 泄露到上层（Domain/Application 层依赖具体实现）

### Interface 层（接口层）
**职责**：处理外部交互（HTTP、gRPC、CLI 等）

**评审重点：**
- [ ] 只依赖 Application 层
- [ ] 处理请求/响应序列化
- [ ] 参数验证
- [ ] 调用应用服务
- [ ] 返回合适的 HTTP 状态码
- [ ] 不包含业务逻辑
- [ ] 使用 DTO 而非直接暴露领域对象

**常见问题：**
- ❌ 包含业务逻辑
- ❌ 直接访问数据库或 Repository
- ❌ 跨层调用 Domain/Infrastructure 层

## SOLID 原则评审清单

### S - 单一职责原则
**检查点：**
- [ ] 结构体/类只负责一个功能领域
- [ ] 方法只做一件事
- [ ] 修改原因只有一个

**反例模式：**
- Service 同时处理验证、持久化、通知
- Repository 包含业务逻辑
- Handler 直接操作数据库

### O - 开闭原则
**检查点：**
- [ ] 通过接口支持扩展
- [ ] 添加新功能不需要修改现有代码
- [ ] 使用策略模式替代 switch/if-else
- [ ] 配置外部化

**反例模式：**
- 每次添加新功能都要修改现有方法
- 大量的 switch/type 判断
- 硬编码的配置项

### L - 里氏替换原则
**检查点：**
- [ ] 子类完全实现父类契约
- [ ] 子类不加强前置条件
- [ ] 子类不减弱后置条件
- [ ] 子类不抛出父类未声明的异常

**反例模式：**
- 子类方法返回 nil 而父类返回 error
- 子类"偷懒"实现（空实现）
- 子类改变方法语义

### I - 接口隔离原则
**检查点：**
- [ ] 接口小而专注
- [ ] 接口方法数量合理（< 10 个）
- [ ] 客户端不依赖不需要的方法
- [ ] 按角色拆分接口

**反例模式：**
- 胖接口（太多方法）
- 客户端被迫实现空方法
- 接口包含不相关的方法

### D - 依赖倒置原则
**检查点：**
- [ ] 高层模块依赖接口而非具体实现
- [ ] 通过构造函数注入依赖
- [ ] 可以在运行时替换实现
- [ ] Domain 层定义接口

**反例模式：**
- Service 直接依赖 *gorm.DB
- 使用 new() 在内部创建依赖
- 高层模块依赖低层模块的具体实现

## 代码质量评审标准

### 命名规范
**标准：**
- 包名：小写、简洁、描述性
- 接口：动词+名词或名词（不以 I 开头）
- 结构体：名词
- 常量：大驼峰或全大写
- 函数：动词开头
- 变量：驼峰命名，语义清晰

**评审标准：**
- ✅ 清晰表达意图
- ✅ 符合语言习惯
- ✅ 避免缩写和单字母（除循环变量）

### 错误处理
**标准：**
- [ ] 所有错误都被检查
- [ ] 错误包含上下文信息（使用 %w）
- [ ] 定义有意义的错误变量
- [ ] 区分业务错误和系统错误
- [ ] 不使用 panic 处理业务错误

**评审标准：**
- ✅ 错误包装保留原始错误
- ✅ 自定义错误类型实现 Error() 方法
- ✅ 调用者能根据错误类型做决策

### 并发安全
**标准：**
- [ ] 共享状态使用 mutex 保护
- [ ] 避免数据竞争
- [ ] 使用 context 管理 goroutine 生命周期
- [ ] 避免死锁

**评审标准：**
- ✅ 使用 sync.RWMutex 优化读写
- ✅ 使用通道进行通信
- ✅ 正确使用 defer 释放锁

### 资源管理
**标准：**
- [ ] 所有打开的资源都关闭
- [ ] 使用 defer 确保资源释放
- [ ] 设置连接池参数
- [ ] 避免资源泄漏

**评审标准：**
- ✅ 文件使用 defer file.Close()
- ✅ HTTP 响应体使用 defer resp.Body.Close()
- ✅ 数据库连接使用连接池

## 性能评审标准

### 数据库查询
**标准：**
- [ ] 避免 N+1 查询
- [ ] 查询使用索引字段
- [ ] 批量操作替代循环查询
- [ ] 大数据量查询分页
- [ ] 避免 SELECT *

**评审标准：**
- ✅ 使用 JOIN 替代循环查询
- ✅ 使用批量插入/更新
- ✅ 合理使用缓存

### 缓存使用
**标准：**
- [ ] 只缓存热点数据
- [ ] 设置合理的过期时间
- [ ] 更新时删除/更新缓存
- [ ] 考虑缓存穿透、雪崩、击穿

**评审标准：**
- ✅ 缓存键名规范
- ✅ 缓存序列化高效
- ✅ 使用缓存预热

## 安全评审标准

### 输入验证
**标准：**
- [ ] 所有用户输入都验证
- [ ] 使用白名单而非黑名单
- [ ] SQL 使用参数化查询
- [ ] 密码加密存储

**评审标准：**
- ✅ 使用验证器（如 go-playground/validator）
- ✅ 限制输入长度
- ✅ 验证数据类型和格式

### 敏感信息保护
**标准：**
- [ ] 日志不包含密码、token
- [ ] API 响应过滤敏感字段
- [ ] 使用 HTTPS 传输
- [ ] 密码使用哈希算法

**评审标准：**
- ✅ 敏感信息脱敏
- ✅ 不在 URL 中传递敏感信息
- ✅ 使用环境变量存储配置

## 注释评审标准

**标准：**
- [ ] 包有注释（doc.go）
- [ ] 导出类型有注释
- [ ] 导出函数有注释
- [ ] 接口有注释
- [ ] 复杂逻辑有注释

**评审标准：**
- ✅ 注释说明"为什么"而非"是什么"
- ✅ 注释与代码同步
- ✅ Go Doc 格式正确

## 日志评审标准

**标准：**
- [ ] 使用正确的日志级别
- [ ] 使用结构化字段
- [ ] 敏感信息脱敏
- [ ] HTTP 处理器使用 Context 版本

**评审标准：**
- ✅ 日志消息动词开头
- ✅ 包含必要的上下文
- ✅ 错误日志包含 logger.Err(err)

## 评审报告格式

```markdown
# Code Review Report

## 📊 评审摘要
- 文件：[文件路径]
- 层级：[Domain/Application/Infrastructure/Interface]
- 问题：X 个严重，X 个中等，X 个轻微
- 评分：X/10

## 🔴 严重问题

### 1. [问题标题]
**位置**: [文件:行号]
**原则**: [违反的原则]
**问题**: [问题描述]
**影响**: [问题影响]
**建议**: [改进建议]
**示例**:
```go
// 改进示例
```

## 🟡 中等问题
[同上格式]

## 🟢 轻微问题
[同上格式]

## ✅ 优秀实践

### 1. [实践标题]
**位置**: [文件:行号]
**描述**: [为什么这是好的实践]

## 📝 改进建议

### 重构建议
[提供具体的重构建议和代码示例]

## 🎯 总结

**优点**:
- [列出代码的优点]

**需要改进**:
- [列出需要改进的方面，按优先级排序]

**下一步行动**:
1. [ ] [具体的行动项]
2. [ ] [具体的行动项]
```

## 评审礼仪

1. **友善建设性**：使用友善的语气，提供建设性反馈
2. **具体明确**：指出具体位置，提供示例代码
3. **解释原因**：说明为什么这样更好，而不只是说"这样更好"
4. **承认主观性**：对于风格问题，承认有不同观点
5. **表扬优秀**：不仅指出问题，也要认可好的实现
6. **提问题**：对于不确定的决策，提问而非命令
7. **区分等级**：区分必须修复和建议修复的问题

## 常见问题模板

### 架构问题
```
违反了 [分层架构/SOLID原则]。
当前实现：[描述当前实现]
问题所在：[违反了什么原则]
建议方案：[提供改进方案]
预期收益：[改进后带来的好处]
```

### 命名问题
```
命名可以更清晰。
当前名称：[当前名称]
建议名称：[建议名称]
原因：[为什么建议的名称更好]
```

### 错误处理问题
```
错误处理可以改进。
当前实现：[描述当前实现]
问题：[错误信息不够详细 / 未包装上下文]
建议：[提供改进方案]
```

### 性能问题
```
存在性能问题。
问题描述：[N+1查询/未使用缓存/其他]
影响：[性能影响的具体描述]
优化建议：[提供优化方案]
预期提升：[预期的性能提升]
```

### 安全问题
```
存在安全风险。
风险类型：[SQL注入/敏感信息泄露/其他]
风险等级：[高/中/低]
修复建议：[提供修复方案]
```
